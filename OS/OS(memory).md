## 메모리 관리 전략
#### 메모리 관리 배경
- 각각의 프로세스는 독립된 메모리 공간을 가짐  
- 운영체제 혹은 다른 프로세스의 메모리 공간에 접근 제한  
- 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 자유로움  

#### Swapping
- 메모리의 관리를 위해 사용되는 기법  
- CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있음  
- Swap에 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할때만 Swapping 시작  

#### 단편화 (Fragmentation)
- 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 메모리 틈 사이에 사용하지 못할 만큼의 작은 자유공간들이 늘어나는 현상  
- 외부 단편화: 분할보다 프로그램이 커서 들어가지 못한 공간  
- 내부 단편화: 분할보다 프로그램이 작아 남는 공간  

#### Paging(페이징)
- 프로세스가 사용하는 메모리는 동일한 크기의 여러 페이지로 나눠서 관리되고(논리 메모리) 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping 되어 저장  
- 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법  
- 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치   
- 외부 단편화를 해결할 수 있는 장점  
- 단점: 내부 단편화 발생  
페이지 크기가 1,024B 이고 프로세스 A가 3,172B 의 메모리를 요구 (1,024 * 3 = 3,072)    
4번째 페이지 프레임에는 924B(3,172 - 3,072)의 여유 공간 (내부 단편화) 발생  

#### Segmentation(세그멘테이션)
- 페이징에과 달리 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할  
- 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위) 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장  

단점: 외부 단편화 발생  


## 가상 메모리
- 물리적 메모리와 논리적 메모리의 개념을 분리하여 작은 물리적 메모리로도 큰 가상 주소 공간을 프로그래머에게 제공  
- 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능  
- 더 많은 프로그램을 동시에 실행가능 (응답시간, CPU 이용률, 처리율 개선)  
- 불필요한 Swap 감소  
- 가상 메모리는 대게 페이지로 관리  

#### 가상 주소 공간  
- 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상으로 구현한 공간  
- 프로세스가 요구하는 메모리 공간을 가상메모리에 제공하고 직접적으로 필요치 않은 메모리 공간은 물리적 메모리에 올리지 않음으로써 메모리를 절약

프로세스간 페이지 공유  
- 각 프로세스들은 공유 라이브러리를 자신의 가상 주소 공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가 있는 물리 메모리 페이지들은 모든 프로세스에 공유  

#### Demand Paging (요구 페이징)
- 프로그램 시작 시에 필요한 부분만 적해나는 전략을 요구 페이징이라 하며, 가상 메모리 시스템에 많이 사용 
- 한번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않음  
- 사용되지 않은 페이지를 가져오는 시간 낭비와 메모리 낭비 방지 

## 페이지 교체
- 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 Page Fault Trap(페이지 부재)가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져옴
- 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄져야함 (또는 운영체제의 프로세스 강제 종료)

#### 기본적인 방법
1. 디스크에서 필요한 페이지의 위치를 찾는다  
2. 빈 페이지 프레임을 찾는다  
3. 페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고른다  
4. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다  
5. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다  
6. 사용자 프로세스 재시작  

#### 페이지 교체 알고리즘
1. FIFO 페이지 교체  
장점  
- 이해하기도 쉽고, 프로그램하기도 쉽다  
단점  
- 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높이는 부작용을 초래 가능  
- Belady의 모순: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재   

2. 최적 페이지 교체(Optimal Page Replacement)  
- Belady의 모순을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행  
- 이 알고리즘의 핵심은 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체  
- 주로 비교 연구 목적을 위해 사용  

장점  
- 알고리즘 중 가장 낮은 페이지 부재율을 보장한다.  
단점  
- 구현의 어려움 (모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문)  

3. LRU 페이지 교체(LRU Page Replacement)  
- LRU: Least-Recently-Used
- 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체
- 대체적으로 FIFO 알고리즘보다 우수. 최적 알고리즘보다는 떨어짐
- 최적 페이지 교체 근사

4. LFU 페이지 교체(LFU Page Replacement)
- LFU: Least Frequently Used
- 참조 횟수가 가장 적은 페이지를 교체하는 방법
- 활발하게 사용되는 페이지는 참조 횟수가 많아질 거라는 가정

- 어떤 프로세스가 특정 페이지를 집중적으로 사용하면 더 이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋나는 시점이 발생
- 최적 페이지 교체 근사 실패
