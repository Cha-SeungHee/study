## 데이터베이스를 사용하는 이유
- 데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리  
- 파일 단위로 저장된 데이터는 애플리케이션과 상호 연동이 되어야 하는데 이 때의 문제점은 데이터 종속성, 중복성, 무결성  

## 데이터베이스의 특징
1. 데이터의 독립성  
1-1) 물리적 독립성  
- 데이터베이스의 물리적 구조(사이즈 또는 새로운 파일)가 변경되더라도 관련 응용 프로그램을 수정할 필요가 없음  
1-2) 논리적 독립성  
- 데이터베이스는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족 가능  
2. 데이터의 무결성  
- 잘못된 데이터 발생을 방지하는 기능  
- 데이터의 유효성 검사를 통해 데이터의 무결성을 구현    
3. 데이터의 보안성  
- 인가된 사용자들만 데이터베이스에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정  
4. 데이터의 일관성   
- 연관된 정보를 논리적인 구조로 관리함으로써 일부 데이터만 변경되는 데이터의 불일치성을 배제   
5. 데이터 중복 최소화  
- 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결  

## 데이터베이스의 성능
- 데이터베이스의 성능 이슈는 디스크 I/O 를 어떻게 줄이느냐에서 시작 
- 디스크 I/O 란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미
- 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정
- 순차 I/O 가 랜덤 I/O 보다 빠를 수 밖에 없다. 
- 하지만 현실에서는 대부분의 I/O 작업이 랜덤 I/O이고 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적

## Index
- 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸림
- TABLE의 컬럼을 색인화(따로 파일로 저장)하여 검색시 색인화 되어있는 INDEX 파일을 검색하여 검색속도 증가
- 인덱스는 항상 정렬된 상태를 유지하기 때문에 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려짐 
- 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능 
- SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.
- 만약 한개의 컬럼에 인덱스를 걸어야 한다면, 해당 컬럼은 카디널리티가 가장 높은 것을 잡아야합니다. 인덱스로 효율을 높히려면 해당 인덱스로 많은 부분을 걸러내야 하기 때문
- 카디널리티(Cardinality)란 해당 컬럼의 중복된 수치 (낮은 카디널리티: 성별, 학년  높은 카디널리티: 주민등록번호, 계좌번호 등)

장점 
- 테이블에서 검색과 정렬 속도를 향상
- 테이블 행의 고유성을 강화

단점 
- 인덱스 된 필드에서 데이터를 업데이트하거나, 레코드를 추가 또는 삭제할 때 성능 저하
- 추가적인 공간 필요
- 인덱스를 생성하는데 시간이 많이 소요 가능

#### Index 자료구조
- 일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘  
- B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리) 원래의 값을 이용해 인덱싱하는 알고리즘  

Hash 인덱스 알고리즘
- 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원  
- 값을 변형해서 인덱싱하므로 특정 문자로 시작하는 값으로 검색을 하는 등 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다  
- 주로 메모리 기반의 데이터베이스에서 많이 사용  

왜 index 를 생성하는데 b-tree 를 사용하는가?  
- SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 되기에 동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않음  

#### Index 의 성능과 고려해야할 사항
- 모든 컬럼에 INDEX 를 생성해두면 빨라지지 않을까? 
- INDEX 를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생 
- INSERT의 경우 INDEX 에 대한 데이터도 추가
- DELETE의 경우 INDEX 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 됨. 즉 row 의 수는 그대로 (INDEX 데이터 수가 실제 데이터 수보다 많아짐)
- UPDATE 의 경우는 INSERT 의 경우, DELETE 의 경우의 문제점을 동시에 수반 (이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오기 때문) 

- 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 달라질 수 있음  

예시)
이름, 나이, 성별 세 가지의 필드를 갖고 있는 테이블을 생각해보자.  
이름은 온갖 경우의 수가 존재할 것이며 나이는 INT 타입을 갖을 것이고, 성별은 남, 녀 두 가지 경우에 대해서만 데이터가 존재할 것임을 쉽게 예측할 수 있다.  
결론부터 말하자면 이름에 대해서만 인덱스를 생성하면 효율적이다.  

왜 성별이나 나이는 인덱스를 생성하면 비효율적일까? 10000 레코드에 해당하는 테이블에 대해서 2000 단위로 성별에 인덱스를 생성했다고 가정하자.   
값의 range 가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O 가 발생하기 때문에 그 만큼 비효율적인 것이다.   

## 정규화
#### 정규화의 배경
- 신중하게 설계되지 않은 테이블에서는 동일한 정보가 중복으로 저장  
- 또한 아래와 같은 갱신 이상이 발생  

1. 삽입 이상
- 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제    

2. 삭제 이상  
- 하나의 자료만 삭제하고 싶지만 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생  

3. 수정(갱신)이상  
- 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점  

#### 정규화란?
- 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업  
- 정규화 과정을 거치게 되면 정규형을 만족  
- 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, … 등이 존재  
