## 인터페이스와 추상클래스에 대해 설명해주세요(용도, 차이 등) => 내용 부족으로 인한 수정 예정
#### 인터페이스
- 구현하는 클래스에 특정한 메서드가 반드시 존재하도록 강제하는 역할 -> 구현 객체의 동일한 동작을 약속하기 위함     
- Java 8부터는 default 키워드를 통해 꼭 정의하지 않아도 됨  
- 다중구현 가능   

#### 추상 클래스
- 실체 클래스에서 공통적인 부분을 추출해 선언한 클래스   
- 추상클래스를 상속받아서 기능을 이용하고 확장하는데 목적  
- 다중상속의 모호성 때문에 하나만 상속 가능  
- 반드시 재정의 해야하는 추상메서드를 통해 규격을 제공   
- 다중상속 불가  

- #인터페이스와 추상클래스로는 인스턴스를 생성할 수 없음 

## static에 대해 설명해주세요
- 메모리에 할당되어 프로그램이 종료될 때 해제  
- JVM 메모리의 Method 영역에 저장  
- 모든 객체가 공유하는 메모리  
- Garbage Collector의 관리 영역 밖에 존재 -> 무분별한 사용시 메모리 낭비  

## final에 대해 설명해주세요  
- 단 한 번만 할당할 수 있도록 제한해주는 키워드  
- 클래스: 해당 클래스 상속 불가  
- 메서드: 해당 메서드 오버라이딩 불가  
- 원시변수: 변수의 값을 변경 불가  
- 참조변수: 다른 객체를 가리키도록 변경 불가  

## 클래스와 인스턴스가 무엇인지 설명해주세요
- 클래스: 문제해결을 위한 데이터를 만들기 위해 '속성'과 '행위'를 변수와 메서드로 정의한 것. 객체를 만들기 위한 틀.     
- 인스턴스: 클래스에서 정의한 것을 토대로 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터  

## 제네릭에 대해 설명해주세요
- 클래스 내부에서 사용하는 데이터의 타입을 클래스의 인스턴스를 생성할 때 결정하는 것  
- 객체의 타입을 컴파일 시점에 체크 -> 타입 안정성  
- 형 변환의 번거로움 감소

## class A <T extends B> 에 대해 설명해주세요
- T 매개변수의 타입은 B 객체 타입이거나 B 클래스를 상속받는 클래스의 타입으로 제한  

## 불변객체에 대해 설명해주세요
- 재할당은 가능  
- 내부상태 변경 불가  
- 원시 타입의 필드는 final 키워드를 사용  
- 참조 타입의 경우에는 추가적인 작업이 필요  

#### 장점  
- 객체에 대한 신뢰도   
- 멀티스레드 환경에서 동기화 처리 없이 객체 공유 가능  

#### 단점  
- 객체가 가지는 값마다 새로운 객체가 필요 -> 메모리 누수와 성능 저하  

#### 사용해야 하는 이유
- Thread-safe하여 병렬 프로그래밍에 유용 (동기화 고려 불필요)  
- 실패 원자적인 메소드를 만들 수 있음  
- Cache, Map, Set 등의 요소로 적합 (데이터 갱신 작업 불필요)    
- GC의 성능 상승 : GC가 스캔해야 하는 객체의 수 감소

## 오버라이딩과 오버로딩에 대해 설명해주세요
#### 오버로딩
- 한 클래스 내에 이름이 같은 메서드를 여러개 정의  
- 파라미터의 자료형이나 갯수가 다르지만 동일한 역할을 하는 메서드를 여러 개 생성  

#### 오버라이딩
- 상위 클래스의 메서드 재정의하는 것  
- 메서드의 반환 타입, 파라미터 등은 모두 동일  
- 내부만 재정의  

## 동등성과 동일성의 차이는?
- 동일성: 두 객체가 같은 객체인 것 (==)  
- 동등성: 두 객체가 동일한 정보를 담고 있는 것 (equals)  

#최상위 클래스인 Object의 equals 메서드는 동일성을 확인

## Java Collection 각각에 대해 설명해주세요
- List, Set, Map, Stack/Queue  
#### List
- 순서가 있는 집합  
- #데이터 중복 허용  
- ArrayList, LinkedList, Vector  

#### Set
- 데이터 순서 유지 X   
- 중복을 허용 X  
- HashSet, TreeSet  

#### Map
- Key와 Value의 쌍으로 이루어진 데이터의 집합  
- 순서 유지 X
- Key 중복 허용 X
- #HashTable, HashMap, TreeMap  

## Java 8에 변경된 부분에 대해 설명해주세요
#### 람다 표현식 
- 불필요한 코드 감소  
- 가독성  

#### 스트림 
- 컬렉션이나 배열의 데이터를 간결

#### 인터페이스
- default 메서드: 해당 메서드를 꼭 구현하지 않아도 됨

#### Optional
- Optional로 캡슐화하여 NPE 방지  

#### Stream API에 대해 설명해주세요.
- 컬렉션, 배열 등의 요소를 하나씩 참조하며 함수형 인터페이스(람다식)를 적용하며 반복적으로 처리할 수 있도록 해주는 기능  
#생성, 중간 연산, 최종 연산  
#### 중간 연산
- map, flatMap, filter 등  
- 스트림을 반환하기 때문에 중간 연산을 연결해서 사용 가능

#### 최종 연산
- collect, reduce 등    

#### 장점
- 선언형 -> 간결함 및 가독성  
- 조립 -> 유연성  

#### 특징
- 내부 반복(internal iteration)을 통해 작업을 수행    
- 단 한번만 연산이 가능    
- 원본 데이터를 변경 X  
- 필터-맵 (filter-map) 기반의 API를 사용 -> 지연(lazy) 연산을 통해 성능을 최적화   
- 손쉬운 병렬 처리 지원  

## 람다식에 대해 설명해주세요
- 로컬 익명 구체를 생성  
- 인터페이스가 가지고 있는 메서드를 간편하게 즉흥적으로 구현해서 사용하기 위함  
- Functional interface    
- 간결한 코드 -> 가독성  
- 디버깅이 까다로움  

## Primitive type VS Reference type
#### Primitive  
- int, double, float 등을 포함한 8가지가 있음
- Null이 될 수 없음  
- Stack 영역에 저장  

#### Reference  
- 클래스 타입, 인터페이스 타입, 배열 타입  
- Null 허용  
- 힙(Heap) 메모리에 저장  

#### Call by value vs Call by reference
#### Call by value
- 함수 호출 시 전달되는 변수 값을 복사해서 함수 인자로 전달  
- 복사된 인자는 함수 안에서 지역적으로 사용 -> 함수 안에서 인자 값이 변경되더라도, 외부 변수 값은 변경이 되지 않음  

#### Call by reference 
- 변수의 레퍼런스를 인자로 전달  
- 함수 안에서 인자 값이 변경되면, 아규먼트로 전달된 객체의 값도 변경  

## Java는 Call by value일까요, Call by reference 일까요?
- Java는 Call by value  
- 인자가 참조 자료형일 때는 레퍼런스를 넘기는 것처럼 보이지만, 인스턴스 메모리 주소를 넘겨주므로 Call by value  
- 함수의 인자가 원시 자료형인 경우엔 값을 넘기므로 당연히 Call by value   

## String VS StringBuilder VS StringBuffer
#### String
- 한번 생성된 String 인스턴스가 갖고 있는 문자열 변경 불가  
- + 연산자를 이용해서 문자열을 결합하는 경우, 인스턴스 내의 문자열이 바뀌는 것이 아니라 새로운 문자열이 담긴 String 인스턴스가 생성  
- GC가 호출되기 전까지 heap에 계속 쌓이므로 메모리 관리 측면에서 치명적  

#### StringBuffer 
- 내부적으로 문자열 편집을 위한 버퍼(buffer) 있음   
- 멀티쓰레드에 안전(thread safe)하도록 동기화  
- 멀티쓰레드로 작성된 프로그램이 아닌 경우 불필요한 성능 저하  

#### StringBuilder 
- StringBuffer에서 쓰레드의 동기화만 뺀 클래스  

## Checked Exception VS Unchecked Exception
#### Checked Exception
- 컴파일 단계에서 발견되는 예외  
- 예외 발생 시 트랜잭션을 roll back X -> 예외 처리 필요  
- 반드시 try/catch 로 감싸거나 throw 로 던져서 처리  
- IOException, SQLException

#### Unchecked Exception
- 실행 단계에서 발견되는 예외
- 명시적인 처리 X 
- 예외 발생 시 트랜잭션을 roll back
- NullPointerException, IllegalArgumentException, IndexOutOfBoundException

## 예외 처리 방법에 대해 설명해주세요.

## Thread Safe란 뭔가요?
- 멀티 프로그래밍에서 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없는 것  

## 그럼 자바에서 Thread Safe하게 코딩하려면 어떻게 해야하나요?
- Synchronized 키워드
- 쓰레드 세이프한 컬렉션

- 쓰레드 세이프한 컬렉션: Vector, HashTable, Synchronized~(List, Map, Set), Concurrent~ 등
