## JVM
- 자바 가상 머신  
- 자바 바이트 코드 실행 주체  
- 운영체제 위에서 동작   
- 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할 (바이트 코드 : 자바 코드를 컴파일해서 얻음)    
- Class Loader, Execution Engine, GC, Runtime Data Area로 구성

#### 장점
- JVM 위에서 바이트코드는 CPU나 운영체제의 종류와 무관하게 실행이 가능 
- GC가 메모리를 자동으로 관리  

#### Classloader
- VM내로 클래스(.class파일)를 로드  
- 링크를 통해 배치  
- 런타임 시에 동적으로 클래스를 로드  

#### Execution Engine
- 메모리에 있는 클래스(바이트 코드)를 기계어로 변경해 명령어 단위로 실행   
- 인터프리터 방식  
- JIT 컴파일러 이용 방식  

#### Garbage Collector
- Heap 메모리 영역에 생성된 객체들 중에 참조되지 않는 객체들을 제거  
- GC 수행시 다른 모든 쓰레드가 일시정지

#### Runtime Data Area (JVM 메모리 공간)
- JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역  
- Method 영역  
- Heap 영역  
- Stack 영역  
- PC Register  
- Native Method Stack  

## JVM 메모리 공간에 대해 설명해주세요.
#### Method 영역
- 클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 공간   

- 필드 정보(멤버 변수의 이름, 데이터 타입, 접근 제어자 정보)  
- 메서드 정보(메서드 이름, 리턴 타입, 접근 제어자 정보)   
- 타입 정보(class인지 interface인지)  
- 상수 풀 등  

#### Heap 영역
- 런타임에 동적으로 할당되는 데이터가 저장되는 영역
- 객체나 배열
- Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역

#### 스택 영역
- 지역변수
- 매개변수
- 메서드 정보
- 임시 데이터 등

#### PC 레지스터
- Thread(쓰레드)가 생성될 때마다 생성되는 영역
- Program Counter: 쓰레드가 실행되는 부분의 주소와 명령을 저장
- CPU의 레지스터와 다름

#### Native Method Stack으로 구성
- 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역

## 자바 프로그램 실행 과정을 설명해주세요
- JVM이 OS로부터 메모리를 할당  
- 자바 컴파일러가 자바 소스코드(.java)를 자바 바이트코드(.class)로 변환  
- Class Loader가 바이트 코드(.class)를 JVM 내로 로드 및 링크하여 Runtime Data Area에 배치
- 실행 엔진(Execution Engine)은 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행

#자바 인터프리터  
바이트 코드 명령어를 하나씩 읽어서 해석하고 실행. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느림  
#JIT 컴파일러(Just-In-Time Compiler)  
인터프리터의 단점을 보완하기 위해 도입된 방식. 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경 방식입니다.  
전체적인 실행속도는 인터프리팅 방식보다 빠름. 

## GC가 무엇인가요?
- 유효하지 않은 메모리 주소인 가비지를 정리  
- Heap 메모리를 재활용하기 위해 참조되지 않는 객체들을 해제  
- 개발자가 직접 메모리 관리를 하지 않아도 된다는 장점  
- GC 실행을 위해 Stop-The-World 상태가 되므로 예측 불가능하게 일시적으로 정지할 수 있다는 단점  

## GC 구성, 과정에 대해 설명해주세요.

## GC 종류별로 설명해주세요. (차이, 특징 등)
