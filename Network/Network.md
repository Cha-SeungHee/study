## HTTP가 뭔가요?
- 텍스트 기반의 통신 규약으로 인터넷에서 데이터를 주고받을 수 있는 프로토콜  
- TCP/ IP를 이용
- 연결 상태 유지하지 않는 비연결성 프로토콜. TCP 연결을 위한 오버헤드를 해결하고자 HTTP 1.1에서 Keep-Alive 기능이 추가    
- 클라이언트의 이전 상태를 알 수 없는 무상태성 프로토콜. 클라이언트를 식별하지 못하는 문제 해결하기 위해 Session과 Cookie를 이용  

#### HTTP 응답 코드
- 200 : 클라이언트의 요청을 정상적으로 수행
- 201 : 클라이언트의 생성 요청을 정상적으로 수행
- 301 : 클라이언트가 요청한 리소스에 대한 URI가 변경 되었음
- 400 : 클라이언트이 부적절한 요청을 함
- 401 : 클라이언트가 인증되지 않은 상태에서 요청함
- 403 : 적절하지 않은 리소스를 클라이언트가 요청함
- 404 : 페이지를 찾을 수 없음
- 405 : 클라이언트가 요청한 리소스에서 사용할 수 없는 Method 를 사용함
- 500 : 서버에 문제가 발생

## 비연결성 (Connectionless)
- 클라이언트가 서버와 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 연결을 끊어 버리는 성질  

- HTTP는 인터넷 상에서 불특정 다수와의 통신을 위해 설계
- 연결을 유지하기 위해 필요한 리소스 발생  
- 연결을 유지하기 위한 리소스를 줄이면 더 많은 연결을 할 수 있음  

- 동일한 클라이언트의 모든 요청에 대해 매번 새로운 연결/해제를 위한 오버헤드 발생

KeepAlive
- 지정된 시간동안 서버와 클라이언트 사이에 패킷 교환이 없을 경우, 상대방의 안부를 묻기 위해 패킷을 주기적으로 보내는 것   
- 패킷에 반응이 없을 경우 연결 해제  
- KeepAlive 상태를 유지하기 위한 메모리 있으므로 주의  


## 무상태성 (Stateless)
- 비연결성으로 인해 서버는 클라이언트 식별 불가  
- 쿠키와 세션 사용하지 않을 시에 쇼핑몰에서 최초 로그인 이후에 페이지를 이동할 때마다 계속 로그인 필요  

1) 쿠키
- 브라우저 단에 쿠키를 저장하여 서버가 클라이언트를 식별할 수 있도록 함  

*동작 방식  
1-1) 클라이언트가 페이지를 요청  
1-2) 서버에서 쿠키를 생성  
1-3) HTTP 헤더에 쿠키를 포함 시켜 응답  
1-4) 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음  
1-5) 쿠키가 존재하면 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보내서 요청  
1-6) 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 경우, 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답  

2) 세션
- 쿠키는 사용자 정보가 브라우저에 저장도기 때문에 보안에 취약  
- 서버에 사용자 정보를 저장하는 방식  
- 쿠키보다는 안전하나 세션 정보 또한 중간에 탈취 당할 수 있음  
- 서버의 메모리 사용 및 동시 접속사 수가 많은 경우 서버 과부하 발생 가능  

*동작 방식
2-1) 클라이언트가 서버에 접속 시 세션 ID를 발급  
2-2) 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장   
2-3) 클라이언트가 서버에 다시 접속 시 이 쿠키를 이용해서 세션 ID 값을 서버에 전달  

3) 토큰 (OAuth, JWT)
- 쿠키와 세션의 문제점을 보완하기 위해 토큰 기반의 인증 방식 도입  
- 보호할 데이터를 토큰으로 치환하여 원본 데이터 대신 토큰을 사용  
- 토큰이 탈취 당하더라도 데이터에 대한 정보를 알 수 없으므로 보안성이 높음  
- OAuth, JWT

## HTTP의 GET과 POST 비교
- HTTP 프로토콜을 이용해서 서버에 요청할 때 사용하는 방식  
- 기술의 목적에 맞게 알맞은 용도에 사용해야한다.  

#### GET
- 데이터가 Request Message의 Header 부분의 url에 담겨서 전송   
- url을 살펴보면 ? 뒤에 데이터가 붙어 request를 보내는 형식  
- url 이라는 공간에 포함되기 때문에 전송할 수 있는 데이터의 크기가 제한적  
- 비밀번호와 같은 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 적절하지 않음   

- 서버에서 어떤 데이터를 가져오는 용도. 서버의 값이나 상태 등을 변경 x  
- GET 방식의 요청은 브라우저에서 Caching 할 수 있음  
- POST 방식으로 요청해야 할 것을 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 caching 되었던 데이터가 응답될 가능성이 존재  

#### POST
- HTTP Message의 Body 부분에 데이터가 담겨서 전송  
- 바이너리 데이터를 요청하는 경우 데이터 크기 및 보안 측면에서 GET 방식보다 유리  
- 보안적인 측면에서는 암호화를 하지 않는 이상 GET 방식에 비해 크게 유리하다고 할 수는 없음 (URL에 데이터가 드러나지 않을 뿐)  

- 서버의 값이나 상태를 변경 또는 추가하기 위해서 사용

## 3-way handshake & 4-way handshake
- SYN: Synchronize sequence number (각 connection별 패킷을 구분하기 위해 Connection별로 새로운 난수를 생성해서 count)
- ACK: Acknowledgement  


#### 연결 성립
1. 클라이언트 -> 서버 : SYN(a) 
2. 서버 -> 클라이언트 : ACK(a+1) & SYN(b)  
3. 클라이언트 -> 서버 : ACK(b+1)  

#서버와 클라이언트가 서로의 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내기 위해서는 2-way handshake로는 부족  
 "대화하자. 내 목소리 들려?" (1-way)  
 "응 들려. 너도 들려?" (2-way)  
 "응 나도 들려" (3-way)  

#### 연결 해제
1. 클라이언트 -> 서버 : FIN  
2. 서버 -> 클라이언트 : ACK  
2-1. 서버는 TIME_OUT (데이터 전송이 종료될 때까지)  
3. 서버 -> 클라이언트 : FIN  
4. 클라이언트 -> 서버 : ACK  

5. 서버 : Close   
6. 클라이언트는 서버가 ACK을 못받았을 경우를 대비해 일정 기간 기다림 (TIME_WAIT). 일정기간 FIN 메시지가 들어오지 않으면 서버가 ACK을 제대로 수신한 걸로 이해하고 종료.  

## TCP vs UDP
- TCP/UDP 모두 Data Integrity만을 위해 고안된 Protocol -> timing, minimum throughput, security에 관련된 기능 제공 x

#### TCP
- 연결형 프로토콜(연결 설정 by 3-way handshake)  
- 신뢰성(flow control, congestion control)  
- 순차적인 전달  

#### UDP
- 비연결형 프로토콜  
- 흐름제어, 오류제어, 손상된 세그먼트 수신에 대한 재전송 x -> 사용자 프로세스의 몫  
- DNS  

#### TCP가 더 reliable한데 왜 UDP를 사용할까?
- 간단한 작업의 경우 TCP의 overhead를 감당하는게 부담  
- Reliability가 중요한 메시지의 경우 application 자체에서 체크할텐데 이러한 경우에는 중복작업일 수 있음  
- Minimum throughput이 중요한 경우 flow 또는 congestion control이 문제가 될 수 있음  

## HTTP와 HTTPS
#### HTTP의 문제점 (암호화하지 않은 프로토콜의 문제점)
- 평문 통신이기에 도청이 가능하다  
- 통신 상대를 확인하지 않기에 위장이 가능  
- 정보의 정확성을 증명할 수 없기에 변조가 가능  

#### TCP/IP는 도청 가능한 네트워크
- TCP/IP 구조의 통신은 패킷을 수집하는 것만으로 도청이 가능  
- 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화 필요    

보완 방법  
1. 통신 방식의 암호화  
- SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 다른 프로토콜을 조합
- SSL과의 조합 -> HTTPS  

2. 콘텐츠의 암호화. 수신하는 측에서는 그 암호를 해독하여 출력하는 처리가 필요.

#### 통신 상대를 확인하지 않기 때문에 위장이 가능
- 누구든지 리퀘스트를 보낼 수 있음  
- IP 주소나 포트 등에서 웹 서버에 대한 액세스 제한이 없는 경우 리스폰스를 반환  
- 이러한 특징은 여러 문제점을 유발  

1. 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인 불가  
2. 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지 확인 불가  
3. 통신하고 있는 상대가 접근이 허가된 상대인지 확인 불가  
4. 통신 상대 확인 불가  
5. 의미없는 리퀘스트도 수신 —> DoS 공격을 방지 불가  

보완 방법  
1. SSL은 상대를 확인하는 수단으로 증명서를 제공
- 증명서는 신뢰할 수 있는 제 3자 기관에 의해 발행  
- 서버나 클라이언트가 실재하고 통신하고자 하는 상대임을 확인  

#### 정보의 정확성을 증명할 수 없기 때문에 변조가 가능하다
#보완 방법
- MD5, SHA-1 등의 해시 값을 확인하는 방법 또는 파일의 디지털 서명 (제한적)
- 확실히 방지하기 위해서는 HTTPS를 사용해야 한다. SSL은 인증, 암호화 기능 제공  

#### HTTPS
- HTTPS = HTTP + 암호화, 인증, 완전성 
- 새로운 애플리케이션 계층의 프로토콜 x
- HTTP 통신하는 소켓을 SSL or TLS 프로토콜로 대체
- 기존: HTTP <-> TCP   변경: HTTP <--> SSL <--> TCP   

#### 모든 웹 페이지에서 HTTPS를 사용하지 않는 이유
- 평문 통신에 비해 암호화 통신은 많은 리소스 필요
- 서버 한 대당 처리할 수 있는 리퀘스트의 수 감소
- 민감한 정보를 다룰 경우에만 HTTPS에 의한 암호화 통신을 

## DNS Round Robin 방식
#### DNS Round Robin
- DNS를 이용해서 하나의 서비스에 여러 대의 서버를 분산시키는 방법
- 사용자가 도메인 주소를 브라우저에 입력하면 DNS는 도메인 정보를 조회
- 여러 서버 IP 리스트 중에서 라운드 로빈 형태로 랜덤하게 하나 또는 여러개를 선택하여 사용자에게 반환
- 최근에는 복수의 IP를 제공하면 클라이언트가 선택

#### DNS Round Robin 방식의 문제점
1. 서버의 수 만큼 공인 IP 주소가 필요. 부하 분산을 위해 서버의 대수를 늘리기 위해서는 그 만큼의 공인 IP 가 필요
2. 균등한 부하 분산 x  
2-1. 스마트폰
- 스마트 폰의 경우 캐리어 게이트웨이라는 프록시 서버를 경유  
- 프록시 서버에서는 이름변환 결과가 일정 시간동안 캐싱  
- 프록시 서버를 경유하는 접속은 항상 같은 서버를 접속  
2-2. PC
- DNS 질의 결과를 캐싱 -> 균등한 부하 분산 x  

- TTL 값을 짧게 설정함으로써 어느 정도 해소가 되지만, TTL에 따라 해제되는 것이 아니라 주의가 필요  

3. 서버 다운 감지 불가  
- DNS 서버는 웹 서버의 부하나 접속 수 등의 상황에 따라 질의결과를 제어불가 -> 다운되더라도 검출하지 못하고 유저들에게 제공  
- 다운된 서버로 연결이 되기도 한다  
- DNS 라운드 로빈은 어디까지나 부하분산을 위한 방법이기에 다른 S/W 와 조합해서 관리할 필요가 있다  

#### 보완 방법 (일부)
DNS 스케줄링 알고리즘

1. Weighted round robin (WRR)  
- 웹 서버에 가중치를 가미해서 분산 비율을 변경  
- 가중치가 큰 서버일수록 빈번하게 선택되므로 처리능력이 높은 서버의 가중치를 높게 설정  

2. Least connection  
- 접속 클라이언트 수가 가장 적은 서버를 선택  
- 로드밸런서에서 실시간으로 connection 수를 관리 또는 각 서버에서 주기적으로 알려주는 것이 필요   

## 웹 통신의 큰 흐름
우리가 Chrome 을 실행시켜 주소창에 특정 URL 값을 입력시키면 어떤 일이 일어나는가?

#### 브라우저
- url에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 의미를 조사
- 조사된 의미에 따라 HTTP Request 메시지 생성 및 웹 서버로 전성
- 만들어진 메시지는 OS에 의뢰하여 전송 
- OS에 송신을 의뢰할 때는 도메인명이 아니라 IP 주소로 메시지를 받을 상대를 지정해야 하는데, 이 과정에서 DNS서버를 조회 필요

#### 프로토콜 스택, LAN 어댑터
- 프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어)이 브라우저로부터 메시지 수신  
- 해당 메시지 패킷 속에 저장  
- 수신처 주소 등의 제어정보를 추가한 후 LAN 어댑터에 패킷 전달  
- LAN 어댑터는 해당 패킷을 전기신호로 변환 및 LAN 케이블에 송출  
- 프로토콜 스택은 통신 중 오류가 발생했을 때, 이 제어 정보를 사용하여 고쳐 보내거나, 각종 상황을 조절하는 등 다양한 역할  

#### 허브, 스위치, 라우터
- LAN 어댑터가 송신한 패킷은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착
- 라우터는 패킷을 프로바이더(통신사)에게 전달
- 패킷 인터넷으로 진입

#### 액세스 회선, 프로바이더
- 패킷은 인터넷의 입구에 있는 액세스 회선(통신 회선)에 의해 POP(Point Of Presence, 통신사용 라우터)까지 운반  
- POP 를 거쳐 인터넷의 핵심부로 진입  
- 수 많은 고속 라우터들을 통해 패킷이 목적지를 향해 흘러가게 된다.

#### 방화벽, 캐시서버
- 패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN에 도착  
- 방화벽이 도착한 패킷을 검사  
- 패킷이 웹 서버까지 가야하는지 가지 않아도 되는지를 판단하는 캐시서버가 존재  
- 액세스한 페이지의 데이터가 캐시서버에 있으면 바로 그 값을 읽음  
- 페이지의 데이터 중에 다시 이용할 수 있는 것이 있으면 캐시 서버에 저장  

#### 웹 서버
- 패킷이 웹 서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 전달
- 메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송
- 이전 방식과 동일한 방식으로 응답 메시지가 클라이언트에게 전달
