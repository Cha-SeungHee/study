### Array
- 논리적 저장 순서와 물리적 저장순서가 일치  
- index로 해당 원소에 접근 가능 (random access)  
- 삭제 또는 삽입을 위해 원소들을 shift해줘야 하는 비용 발생 - O(n)  
  
### LinkedList
- 각각의 원소는 다음 원소를 기억  
- 다음 원소에 대한 값을 다른 값으로 바꿔주면 삭제와 삽입을 O(1) 만에 해결 가능  
- 하지만 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문에 특정 원소를 찾기 위해 O(n)의 시간이 소요  
- 삽입과 삭제를 위해서는 해당 원소를 찾아야 하기 때문에 결국 검색, 삽입, 삭제에 대해서 모두 O(n)의 time complexity 소요  
- Tree 구조에 많이 활용되는 자료구조  

### Stack
- Last In First Out (LIFO) 특성의 선형 자료구조  

### Queue
- First In First Out (FIFO) 특성의 선형 자료구조  
- Java Collection에서 Queue는 인터페이스  

### Tree
- 스택, 큐와 달리 비선형 자료구조  
- 계층 관계를 표현하는데 유용  
- 구성요소: 노드(Root node, terminal node, internal node), 간선  

### Binary Tree
- 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어 진다  
- 나뉘어진 두 서브 트리 또한 이진 트리  
- 공집합 또한 이진 트리    

- 트리의 각 층 = 레벨  
- 루트 노드의 레벨은 0  
- i번째의 노드에 대해 부모 노드 index는 i/2, 왼쪽 자식 노드 index는 2i, 오른쪽 자식 노드 index는 2i + 1  

#### Perfect Binary Tree, Complete Binary Tree, Full Binary Tree 
- Perfect Binary Tree(포화): 모든 레벨이 꽉 찬 이진 트리  
- Complete Binary Tree(완전): 위에서 아래로, 왼쪽에서 오른쪽으로 채워진 이진 트리  
- Full Binary Tree(정): 모든 노드가 0개 혹은 2개의 자식 노드만을 갖는 이진 트리  

### Binary Search Tree
- 이진 트리의 일종으로 다음과 같은 저장 규칙을 가진 트리  

#### 규칙
규칙1. 이진 탐색 트리 노드에 저장된 키는 유일  
규칙2. 부모의 키가 왼쪽 자식 노드의 키보다 크다
규칙3. 부모의 키가 오른쪽 자식 노드의 키보다 작다  
규칙4. 왼쪽과 오른쪽 서브트리도 이진탐색트리이다  

- 이진 탐색 트리의 연산은 O(log n)의 시간복잡도  
- 저장 순서에 따라 한 방향으로만 추가되는 편향 트리가 될 수 있으며 최악의 경우 O(n)의 시간 복잡도  

### Binary Heap
- Complete Binary Tree 기반  
- 루트노드는 1번부터 시작 (index번호와 노드 번호를 일치시켜 혼동 줄이기 위함)  
- 최대힙, 최소힙  

#### 최대힙 (최소힙)
- 각 노드의 값이 해당 자식의 값보다 크거나 같은 Complete binary tree  
- 루트노드의 값이 최대값 (최소힙의 경우는, 최소값)  
- 최대값, 최소값을 꺼낸 이후에는 힙 구조를 유지하기 위해 heapify 과정을 거친다  
- Heapify: 맨 마지막 노드를 루트 노드로 대체시킨 후 힙 구조를 유지하도록 정렬  
- O(log n)의 시간복잡도로 최대값 또는 최소값에 접근 가능  

### Red-Black Tree
- Binary Search Tree의 한 종류  
- Search, Insert, Delete 에 O(log n)의 시간 복잡도가 소요  
- 동일한 노드의 개수일 때, depth 를 최소화하여 시간 복잡도를 줄이는 것이 핵심  

#### 정의
- Red-Black Tree 는 다음의 성질들을 만족하는 BST  

#### 조건
0. 모든 노드는 빨강 혹은 검정  
1. 루트노드의 색깔은 검정  
2. 모든 단말노드는 검정  
3. 빨강 노드의 자식은 검정  => 빨강 노드가 연속으로 나올 수 없다  
4. 모든 노드에 대해서 그 노드로부터 자손인 leaf node로 이르는 모든 경로에는 동일한 개수의 검정 노드가 존재  

- BST의 특징을 모두 갖는다  
- Root node 부터 leaf node까지의 경로 중 최소 경로와 최대 경로의 크기 비율은 2 보다 크지 않다 (balanced 상태)   
- 노드의 child 가 없을 경우 child 를 가리키는 포인터는 NIL 값을 저장  
- NIL들을 leaf node로 간주  

#### 왜 균형 잡히는가
- 조건 3번에 의해 두 개의 빨간 노드가 경로상에서 인접할 수 없음  
- 즉 빨간 노드는 경로상 노드의 절반보다 많을 수 없음  
- 이로 인해 빨간색 노드의 개수가 최소일 때는 0개 (해당 경로에는 총 B개의 노드), 최대일 때는 B개 (경로에는 총 2B개의 노드)  
- 최악의 경우에도 두 경로의 차이가 2배보다 적으며 검색과 삽입 연산이 O(log N)안에 가능  

#### 삽입
1. 삽입되는 노드의 색깔은 빨강 (NIL 노드와 교체)  
2. Red-Black Tree의 조건을 위반하는 경우 조정  
3. 이 과정을 통해 동일한 높이에 존재하는 node들의 black-height가 같아지고 최소 경로와 최대 경로의 크기 비율이 2 미만으로 유지  
c.f) 삽입된 노드의 색깔은 빨강. 어떤 경로에서도 검은색 노드의 개수를 바꾸지 않았기에 검은색 위반 발생 x  

삽입된 노드: N / 부모 노드: P / 부모의 부모 노드: G / Uncle 노드: U

- 삽입된 노드의 uncle node의 색깔에 따라 수행되는 방식이 다름  

#### 삽입 - U가 검은색
- N, P, G를 정렬  
- 정렬 후 가운데 값을 부모 노드로 만들고 나머지 두 노드를 삽입  
- 부모 노드를 검정으로 변경 (나머지 자식 노드는 빨강)  
- Uncle 노드 또한 추가  
- 다른 sub-tree에 영향이 없음 (black depth)  
- restructuring 자체의 시간복잡도는 O(1)이나 삽입하는 과정을 포함하면 O(n)  
- 이 과정을 회전이라 볼 수도 있음  

- 핵심은 이진 탐색 트릐의 순서를 지키는 것 (중위순회로 확인 가능)  
- 검은색 위반을 발생시키는지 확인  

#### 삽입 - U가 빨간색
- U, P: 빨강, G: 검정
- U, P와 G의 색깔 변경 (U, P: 검정, G: 빨강)
- G의 부모와 빨간색 위반 발생하고 이러면 재귀적으로 위반을 처리  
- Recoloring 자체는 O(1), 삽입하는 과정을 포함하여 O(n)  

#### 삭제
- 삭제된 노드가 빨강인 경우 추가 작업 불필요  
- 검은색 노드를 삭제하는 경우 그 자리를 대체하는 노드를 검은색으로 칠함  
- 대체하는 노드의 색깔이 검정일 경우, 이중흑색노드 발생  

#### 삭제 - 이중흑색노드 처리

### Hash Table
- 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다  
- 해시 함수를 이용하여 저장할 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용  
- 데이터 고유의 인덱스로 접근하게 되므로 평균적으로 O(1) - 평균적으로 O(1)인 것은 collision 때문  

#### Hash Function
- 해시코드: 해시 함수에 의해 변환된 데이터의 고유 숫자값
- 다른 데이터에 대해 동일한 해시코드 값이 도출되는 경우 -> 충돌  
- 충돌을 최소화 하는 방향으로 설계하고 collision에 대비하는 것이 중요  
- 충돌이 늘어날수록 O(1)에서 O(n)에 가까워짐 

#### 충돌 해결 방식
1. Open Address 방식  
- 충돌 발생시 다른 해시 버킷에 해당 자료를 삽입하는 방식  
- Worst case: 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치로 돌아옴  
- 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아짐  
- Linear Probing, Quadratic Probing, Double Hashing Probing  

2. Separate Chaining 방식  
1) 연결리스트
- 버킷을 연결리스트로 만들어 충돌시 해당 리스트에 추가  
- 삽입/삭제가 간단  
- 데이터가 작을 경우 연결리스트 자체가 오버헤드  

2) 트리
- 트리는 기본적으로 메모리 사용량이 많기 때문에 데이터가 적을 때는 연결리스트  

3) Open Address vs Separate Chaining  
- Open Address 방식이 연속된 공간에 데이터를 저장하기에 캐시 효율이 높음  
- Separate Chaining은 테이블의 확장을 보다 늦출 수 있음  

4) 해시버킷 동적확장  
- Load factor(0.75): 데이터 개수가 해시 버킷 개수의 75%가 되면 버킷의 개수를 두배로 늘림 -> 충돌로 인한 성능 손실 대비  
  
### 그래프


https://zeddios.tistory.com/237
https://assortrock.com/88
